// internal/jsoncompare/compare.go
package jsoncompare

import (
	"encoding/json"
	"fmt"
	"reflect"

	"github.com/google/go-cmp/cmp"
	"github.com/google/go-cmp/cmp/cmpopts"
)

// CompareResult holds the outcome of the comparison and a detailed diff.
type CompareResult struct {
	AreEqual bool
	// Diff is generated by go-cmp, showing differences between the normalized structures.
	Diff string
	// NormalizedA and NormalizedB are included for debuggability.
	NormalizedA interface{}
	NormalizedB interface{}
}

// Options allows customization of the comparison behavior.
type Options struct {
	Rules            HeuristicRules
	IgnoreArrayOrder bool // Enables order-agnostic comparison of arrays.
	EquateEmpty      bool // Treats nil and empty slices/maps as equal (e.g., {} == null).
}

// DefaultOptions returns options using DefaultRules, enabling EquateEmpty and IgnoreArrayOrder.
func DefaultOptions() Options {
	return Options{
		Rules:            DefaultRules(),
		IgnoreArrayOrder: true,
		EquateEmpty:      true,
	}
}

// Compare performs a full semantic comparison of two JSON byte arrays using the specified options.
func Compare(jsonA, jsonB []byte, opts Options) (*CompareResult, error) {
	var dataA, dataB interface{}

	// 1. Parse JSON into generic interface{} types.
	if err := json.Unmarshal(jsonA, &dataA); err != nil {
		return nil, fmt.Errorf("failed to parse JSON A: %w", err)
	}
	if err := json.Unmarshal(jsonB, &dataB); err != nil {
		return nil, fmt.Errorf("failed to parse JSON B: %w", err)
	}

	// 2. Normalize the parsed data structures.
	normalizer := NewNormalizer(opts.Rules)
	normalizedA := normalizer.Normalize(dataA)
	normalizedB := normalizer.Normalize(dataB)

	// 3. Compare the normalized structures using google/go-cmp.
	cmpOptions := buildCmpOptions(opts)
	diff := cmp.Diff(normalizedA, normalizedB, cmpOptions...)
	areEqual := (diff == "")

	result := &CompareResult{
		AreEqual:    areEqual,
		Diff:        diff,
		NormalizedA: normalizedA,
		NormalizedB: normalizedB,
	}

	return result, nil
}

// buildCmpOptions assembles the necessary options for the go-cmp library.
func buildCmpOptions(opts Options) cmp.Options {
	var cmpOpts cmp.Options

	if opts.EquateEmpty {
		cmpOpts = append(cmpOpts, cmpopts.EquateEmpty())
	}

	if opts.IgnoreArrayOrder {
		// Sort all slices for order-agnostic comparison.
		cmpOpts = append(cmpOpts, cmpopts.SortSlices(genericSliceLess))
	}

	// This filter is crucial. It ensures that the slice of values collected from
	// dynamic keys is ALWAYS sorted, even if IgnoreArrayOrder is false. This is
	// required for the dynamic key normalization strategy to work correctly.
	cmpOpts = append(cmpOpts, cmp.FilterPath(isDynamicKeyPath, cmpopts.SortSlices(genericSliceLess)))

	return cmpOpts
}

// isDynamicKeyPath is a cmp.FilterPath function that returns true if the path
// ends in the placeholder key used by the normalizer.
func isDynamicKeyPath(p cmp.Path) bool {
	if step, ok := p.Last().(cmp.MapIndex); ok {
		if key, ok := step.Key().Interface().(string); ok {
			return key == PlaceholderDynamicKey
		}
	}
	return false
}

// genericSliceLess provides a "less than" function for sorting slices of `interface{}`,
// which is required by cmpopts.SortSlices. It establishes a deterministic sort order.
func genericSliceLess(x, y interface{}) bool {
	vx := reflect.ValueOf(x)
	vy := reflect.ValueOf(y)

	// A nil value is always considered "less than" a non-nil value.
	if !vx.IsValid() {
		return vy.IsValid()
	}
	if !vy.IsValid() {
		return false
	}

	// If types differ, sort by type name for a stable order (e.g., all bools before all floats).
	if vx.Type() != vy.Type() {
		return vx.Type().String() < vy.Type().String()
	}

	switch vx.Kind() {
	case reflect.String:
		return vx.String() < vy.String()
	case reflect.Float64: // JSON numbers are parsed as float64
		return vx.Float() < vy.Float()
	case reflect.Bool:
		return !vx.Bool() && vy.Bool() // false < true
	default:
		// For complex types (maps, slices), use fmt.Sprint as a fallback.
		// This provides a deterministic order, though not semantically meaningful.
		return fmt.Sprint(x) < fmt.Sprint(y)
	}
}
