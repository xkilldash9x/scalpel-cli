// internal/browser/layout/layout.go
package layout

import (
	"fmt"
	"math"
	"sort"
	"strings"

	"github.com/antchfx/htmlquery"
	"golang.org/x/net/html"

	"github.com/xkilldash9x/scalpel-cli/api/schemas"
	"github.com/xkilldash9x/scalpel-cli/internal/browser/parser"
)

// --- Core Structures: Box Model and Dimensions ---

// Dimensions defines the geometry of a layout box.
type Dimensions struct {
	// Content area (x, y) relative to the viewport.
	Content Rect
	Padding Edges
	Border  Edges
	Margin  Edges
}

type Rect struct {
	X, Y, Width, Height float64
}

type Edges struct {
	Top, Right, Bottom, Left float64
}

// --- Layout Tree (Box Tree) ---

// BoxType defines the type of box generated by a node.
type BoxType int

const (
	BlockBox BoxType = iota
	InlineBox
	AnonymousBlockBox // Used for text nodes or inline children within a block container.
)

// LayoutBox is a node in the Layout Tree. It represents a rectangular area on the page.
type LayoutBox struct {
	Dimensions Dimensions
	BoxType    BoxType
	// Reference back to the styled node (which holds the DOM node and computed styles).
	StyledNode *StyledNode
	Children   []*LayoutBox
}

func NewLayoutBox(boxType BoxType, styledNode *StyledNode) *LayoutBox {
	return &LayoutBox{
		BoxType:    boxType,
		StyledNode: styledNode,
	}
}

// GetInlineContainer manages the creation of AnonymousBlockBoxes for inline content within a block flow.
func (b *LayoutBox) GetInlineContainer() *LayoutBox {
	switch b.BoxType {
	case InlineBox, AnonymousBlockBox:
		return b
	case BlockBox:
		// If the last child is an anonymous block box, reuse it.
		if len(b.Children) > 0 {
			if lastChild := b.Children[len(b.Children)-1]; lastChild.BoxType == AnonymousBlockBox {
				return lastChild
			}
		}
		// Otherwise, create a new anonymous block box.
		anonBox := NewLayoutBox(AnonymousBlockBox, nil)
		b.Children = append(b.Children, anonBox)
		return anonBox
	}
	return b
}

// --- Style Tree ---

// StyledNode represents a DOM node combined with its computed styles.
type StyledNode struct {
	Node *html.Node
	// Map of CSS property names to their computed values.
	ComputedStyles map[parser.Property]parser.Value
	Children       []*StyledNode
}

// Value retrieves a computed style, falling back if not present.
func (sn *StyledNode) Value(property parser.Property) (parser.Value, bool) {
	val, ok := sn.ComputedStyles[property]
	return val, ok
}

// Display determines the layout mode (block, inline, or none).
func (sn *StyledNode) Display() DisplayType {
	// Text nodes are always inline.
	if sn.Node.Type == html.TextNode {
		return DisplayInline
	}

	if display, ok := sn.Value("display"); ok {
		switch display {
		case "block", "flex", "grid", "table": // Treat major layout models as block initially.
			return DisplayBlock
		case "none":
			return DisplayNone
		case "inline", "inline-block":
			return DisplayInline
		}
	}
	// Default depends on the element type (User Agent stylesheet).
	return getDefaultDisplay(sn.Node)
}

type DisplayType int

const (
	DisplayInline DisplayType = iota
	DisplayBlock
	DisplayNone
)

// IsVisible checks if the element is visually rendered (not display:none or visibility:hidden).
func (sn *StyledNode) IsVisible() bool {
	if sn.Display() == DisplayNone {
		return false
	}
	if visibility, ok := sn.Value("visibility"); ok {
		if visibility == "hidden" || visibility == "collapse" {
			return false
		}
	}
	return true
}

// getDefaultDisplay provides a very basic User Agent stylesheet equivalent.
func getDefaultDisplay(node *html.Node) DisplayType {
	if node.Type != html.ElementNode {
		return DisplayInline
	}
	switch strings.ToLower(node.Data) {
	case "html", "body", "div", "p", "h1", "h2", "h3", "h4", "h5", "h6", "ul", "ol", "li", "form", "header", "footer", "section", "article", "nav", "main":
		return DisplayBlock
	default:
		return DisplayInline
	}
}

// --- Engine Core ---

// Engine is responsible for parsing CSS, building the style tree, and generating the layout tree.
type Engine struct {
	styleSheets []parser.StyleSheet
}

func NewEngine() *Engine {
	return &Engine{}
}

// AddStyleSheet adds a parsed stylesheet to the engine's context.
func (e *Engine) AddStyleSheet(sheet parser.StyleSheet) {
	e.styleSheets = append(e.styleSheets, sheet)
}

// Render builds the Style Tree and then the Layout Tree for the given DOM root.
func (e *Engine) Render(root *html.Node, viewportWidth, viewportHeight float64) *LayoutBox {
	styleTree := e.BuildStyleTree(root)
	layoutTree := e.BuildLayoutTree(styleTree)

	if layoutTree == nil {
		// Root element is display: none.
		return nil
	}

	// The initial containing block matches the viewport dimensions.
	initialContainingBlock := Dimensions{
		Content: Rect{X: 0, Y: 0, Width: viewportWidth, Height: viewportHeight},
	}

	// Calculate the layout dimensions.
	layoutTree.Layout(initialContainingBlock)

	return layoutTree
}

// --- Style Tree Construction (The Cascade) ---

// BuildStyleTree constructs the StyledNode tree by applying stylesheets to the DOM.
func (e *Engine) BuildStyleTree(node *html.Node) *StyledNode {
	computedStyles := make(map[parser.Property]parser.Value)

	// Apply styles only to element nodes. Text nodes inherit styles.
	if node.Type == html.ElementNode {
		computedStyles = e.CalculateStyles(node)
	}

	styledNode := &StyledNode{
		Node:           node,
		ComputedStyles: computedStyles,
	}

	// Recursively style children.
	for c := node.FirstChild; c != nil; c = c.NextSibling {
		// Skip comments.
		if c.Type == html.CommentNode {
			continue
		}
		// Skip <head> and its children for layout purposes.
		if node.Type == html.ElementNode && strings.ToLower(node.Data) == "html" && strings.ToLower(c.Data) == "head" {
			continue
		}

		childStyled := e.BuildStyleTree(c)

		// Handle inheritance.
		e.inheritStyles(childStyled, styledNode)

		styledNode.Children = append(styledNode.Children, childStyled)
	}

	return styledNode
}

// inheritStyles applies basic inheritance from parent to child.
func (e *Engine) inheritStyles(child, parent *StyledNode) {
	// Simplified list of inheritable properties.
	inheritableProperties := []parser.Property{"color", "font-family", "font-size", "font-weight", "line-height", "text-align", "visibility"}

	for _, prop := range inheritableProperties {
		// If the child doesn't have the property explicitly set, inherit from the parent.
		if _, exists := child.ComputedStyles[prop]; !exists {
			if val, parentHas := parent.ComputedStyles[prop]; parentHas {
				child.ComputedStyles[prop] = val
			}
		}
	}
}

type MatchedRule struct {
	Rule        parser.RuleSet
	Specificity struct{ A, B, C int }
}

// CalculateStyles determines the computed styles for a given DOM node using the cascade.
func (e *Engine) CalculateStyles(node *html.Node) map[parser.Property]parser.Value {
	var matchedRules []MatchedRule

	// 1. Find all matching rules.
	for _, sheet := range e.styleSheets {
		for _, rule := range sheet.Rules {
			for _, selector := range rule.Selectors {
				if e.matches(node, selector) {
					a, b, c := selector.CalculateSpecificity()
					matchedRules = append(matchedRules, MatchedRule{
						Rule:        rule,
						Specificity: struct{ A, B, C int }{a, b, c},
					})
				}
			}
		}
	}

	// 2. Sort rules by specificity (The Cascade). Stable sort ensures later rules win ties.
	sort.SliceStable(matchedRules, func(i, j int) bool {
		s1 := matchedRules[i].Specificity
		s2 := matchedRules[j].Specificity
		if s1.A != s2.A {
			return s1.A < s2.A
		}
		if s1.B != s2.B {
			return s1.B < s2.B
		}
		return s1.C < s2.C
	})

	// 3. Apply rules in order.
	styles := make(map[parser.Property]parser.Value)
	for _, matched := range matchedRules {
		for _, decl := range matched.Rule.Declarations {
			styles[decl.Property] = decl.Value
		}
	}

	// 4. Handle inline styles (FUTURE IMPROVEMENT).

	return styles
}

// matches checks if a DOM node matches a simple CSS selector.
func (e *Engine) matches(node *html.Node, selector parser.Selector) bool {
	if node.Type != html.ElementNode {
		return false
	}

	// Check Tag Name
	if selector.TagName != "" && selector.TagName != "*" && strings.ToLower(node.Data) != selector.TagName {
		return false
	}

	// Check ID
	if selector.ID != "" {
		idFound := false
		for _, attr := range node.Attr {
			if attr.Key == "id" && attr.Val == selector.ID {
				idFound = true
				break
			}
		}
		if !idFound {
			return false
		}
	}

	// Check Classes
	if len(selector.Classes) > 0 {
		var nodeClasses []string
		for _, attr := range node.Attr {
			if attr.Key == "class" {
				nodeClasses = strings.Fields(attr.Val)
				break
			}
		}

		for _, requiredClass := range selector.Classes {
			found := false
			for _, nodeClass := range nodeClasses {
				if nodeClass == requiredClass {
					found = true
					break
				}
			}
			if !found {
				return false
			}
		}
	}

	return true
}

// --- Layout Tree Construction ---

// BuildLayoutTree constructs the LayoutBox tree from the Style Tree, excluding non-rendered elements.
func (e *Engine) BuildLayoutTree(styledNode *StyledNode) *LayoutBox {
	// Determine the box type based on the 'display' property.
	var root *LayoutBox
	switch styledNode.Display() {
	case DisplayNone:
		return nil // Do not generate a box for display: none.
	case DisplayBlock:
		root = NewLayoutBox(BlockBox, styledNode)
	case DisplayInline:
		// Optimization: Do not create boxes for whitespace-only text nodes in the layout tree.
		if styledNode.Node.Type == html.TextNode && strings.TrimSpace(styledNode.Node.Data) == "" {
			return nil
		}
		root = NewLayoutBox(InlineBox, styledNode)
	}

	// Recursively build the layout tree for children.
	for _, child := range styledNode.Children {
		switch child.Display() {
		case DisplayNone:
			continue
		case DisplayBlock:
			if box := e.BuildLayoutTree(child); box != nil {
				root.Children = append(root.Children, box)
			}
		case DisplayInline:
			// Inline children are placed inside a container (which might be anonymous).
			if box := e.BuildLayoutTree(child); box != nil {
				container := root.GetInlineContainer()
				container.Children = append(container.Children, box)
			}
		}
	}
	return root
}

// --- Layout Algorithm (Block and Inline Flow) ---

// Layout calculates the dimensions and position of the LayoutBox and its descendants.
func (b *LayoutBox) Layout(containingBlock Dimensions) {
	switch b.BoxType {
	case BlockBox:
		b.layoutBlock(containingBlock)
	case InlineBox:
		// Inline layout is simplified.
		b.layoutInline(containingBlock)
	case AnonymousBlockBox:
		b.layoutAnonymous(containingBlock)
	}
}

// layoutBlock implements the standard CSS block layout algorithm.
func (b *LayoutBox) layoutBlock(containingBlock Dimensions) {
	// 1. Calculate width and horizontal edges.
	b.calculateBlockWidth(containingBlock)
	// 2. Calculate position (vertical edges and X/Y coordinates).
	b.calculateBlockPosition(containingBlock)
	// 3. Layout children (which determines the height).
	b.layoutChildren()
	// 4. Adjust height based on children (if height was auto).
	b.calculateBlockHeight()
}

// layoutInline implements basic inline layout (simplified, no line breaking).
func (b *LayoutBox) layoutInline(containingBlock Dimensions) {
	// 1. Calculate edges.
	b.calculateInlineEdges(containingBlock)

	// 2. Position the box. X/Y are determined by the flow (handled in parent's layoutChildren).
	d := &b.Dimensions
	d.Content.X = containingBlock.Content.X + d.Margin.Left + d.Border.Left + d.Padding.Left
	d.Content.Y = containingBlock.Content.Y + d.Margin.Top + d.Border.Top + d.Padding.Top

	// 3. Layout children (estimates width and height).
	b.layoutChildren()

	// 4. Calculate dimensions based on children extent (shrink-to-fit).
	b.calculateInlineDimensions(containingBlock)
}

// layoutAnonymous handles the layout of anonymous block boxes wrapping inline content.
func (b *LayoutBox) layoutAnonymous(containingBlock Dimensions) {
	// Anonymous boxes inherit dimensions from their containing block initially.
	b.Dimensions.Content.X = containingBlock.Content.X
	b.Dimensions.Content.Y = containingBlock.Content.Y
	b.Dimensions.Content.Width = containingBlock.Content.Width

	// They contain inline children.
	b.layoutChildren()
	// Their height is determined by their content.
	b.calculateBlockHeight()
}

// calculateBlockWidth computes the width of a block-level box.
func (b *LayoutBox) calculateBlockWidth(containingBlock Dimensions) {
	if b.StyledNode == nil {
		return
	}
	styles := b.StyledNode.ComputedStyles
	d := &b.Dimensions

	// Simplified lookup.
	width := lookupStyle(styles, "width", "auto")
	marginLeft := lookupStyle(styles, "margin-left", "0")
	marginRight := lookupStyle(styles, "margin-right", "0")
	paddingLeft := lookupStyle(styles, "padding-left", "0")
	paddingRight := lookupStyle(styles, "padding-right", "0")
	borderLeft := lookupStyle(styles, "border-left-width", "0")
	borderRight := lookupStyle(styles, "border-right-width", "0")

	// Convert values to pixels.
	wVal := parseLength(width, containingBlock.Content.Width)
	mlVal := parseLength(marginLeft, containingBlock.Content.Width)
	mrVal := parseLength(marginRight, containingBlock.Content.Width)
	plVal := parseLength(paddingLeft, containingBlock.Content.Width)
	prVal := parseLength(paddingRight, containingBlock.Content.Width)
	blVal := parseLength(borderLeft, 0) // Borders typically don't use percentage
	brVal := parseLength(borderRight, 0)

	// Basic implementation of the box model constraint equation.

	// If width is auto, it takes the remaining space.
	if width == "auto" {
		if marginLeft == "auto" {
			mlVal = 0
		}
		if marginRight == "auto" {
			mrVal = 0
		}

		wVal = containingBlock.Content.Width - mlVal - mrVal - plVal - prVal - blVal - brVal
		if wVal < 0 {
			wVal = 0
		}
	}

	// Handle auto margins (centering).
	if width != "auto" {
		remainingSpace := containingBlock.Content.Width - wVal - plVal - prVal - blVal - brVal

		if marginLeft == "auto" && marginRight == "auto" {
			if remainingSpace > 0 {
				mlVal = remainingSpace / 2
				mrVal = remainingSpace / 2
			} else {
				mlVal = 0
				mrVal = 0
			}
		} else if marginLeft == "auto" {
			mlVal = max(0, remainingSpace)
			mrVal = parseLength(marginRight, containingBlock.Content.Width) // Ensure non-auto margin is calculated
		} else if marginRight == "auto" {
			mrVal = max(0, remainingSpace)
			mlVal = parseLength(marginLeft, containingBlock.Content.Width) // Ensure non-auto margin is calculated
		}
	}

	d.Content.Width = wVal
	d.Margin.Left = mlVal
	d.Margin.Right = mrVal
	d.Padding.Left = plVal
	d.Padding.Right = prVal
	d.Border.Left = blVal
	d.Border.Right = brVal
}

// calculateBlockPosition determines the vertical positioning (Y coordinate) of the box.
func (b *LayoutBox) calculateBlockPosition(containingBlock Dimensions) {
	if b.StyledNode == nil {
		return
	}
	styles := b.StyledNode.ComputedStyles
	d := &b.Dimensions

	// Calculate vertical edges. We use container width for percentage reference as per CSS spec for block layout vertical margins/padding.
	d.Margin.Top = parseLength(lookupStyle(styles, "margin-top", "0"), containingBlock.Content.Width)
	d.Margin.Bottom = parseLength(lookupStyle(styles, "margin-bottom", "0"), containingBlock.Content.Width)
	d.Padding.Top = parseLength(lookupStyle(styles, "padding-top", "0"), containingBlock.Content.Width)
	d.Padding.Bottom = parseLength(lookupStyle(styles, "padding-bottom", "0"), containingBlock.Content.Width)
	d.Border.Top = parseLength(lookupStyle(styles, "border-top-width", "0"), 0)
	d.Border.Bottom = parseLength(lookupStyle(styles, "border-bottom-width", "0"), 0)

	// Position the box relative to the containing block's content area.
	d.Content.X = containingBlock.Content.X + d.Margin.Left + d.Border.Left + d.Padding.Left

	// The Y coordinate relies on the containingBlock.Content.Y passed down, which accumulates offsets from previous siblings.
	d.Content.Y = containingBlock.Content.Y + d.Margin.Top + d.Border.Top + d.Padding.Top
}

// calculateInlineEdges computes the edges for inline elements.
func (b *LayoutBox) calculateInlineEdges(containingBlock Dimensions) {
	if b.StyledNode == nil {
		return
	}
	styles := b.StyledNode.ComputedStyles
	d := &b.Dimensions

	// Calculate horizontal edges based on the containing block width.
	d.Margin.Left = parseLength(lookupStyle(styles, "margin-left", "0"), containingBlock.Content.Width)
	d.Margin.Right = parseLength(lookupStyle(styles, "margin-right", "0"), containingBlock.Content.Width)
	d.Padding.Left = parseLength(lookupStyle(styles, "padding-left", "0"), containingBlock.Content.Width)
	d.Padding.Right = parseLength(lookupStyle(styles, "padding-right", "0"), containingBlock.Content.Width)
	d.Border.Left = parseLength(lookupStyle(styles, "border-left-width", "0"), 0)
	d.Border.Right = parseLength(lookupStyle(styles, "border-right-width", "0"), 0)

	// Vertical edges (simplified for inline).
	d.Margin.Top = parseLength(lookupStyle(styles, "margin-top", "0"), containingBlock.Content.Width)
	d.Margin.Bottom = parseLength(lookupStyle(styles, "margin-bottom", "0"), containingBlock.Content.Width)
	d.Padding.Top = parseLength(lookupStyle(styles, "padding-top", "0"), containingBlock.Content.Width)
	d.Padding.Bottom = parseLength(lookupStyle(styles, "padding-bottom", "0"), containingBlock.Content.Width)
	d.Border.Top = parseLength(lookupStyle(styles, "border-top-width", "0"), 0)
	d.Border.Bottom = parseLength(lookupStyle(styles, "border-bottom-width", "0"), 0)
}

// layoutChildren iterates over children and lays them out based on the current flow context.
func (b *LayoutBox) layoutChildren() {
	currentYOffset := 0.0
	currentXOffset := 0.0

	// The containing block for children is the parent's content area.
	container := b.Dimensions

	for _, child := range b.Children {

		// Determine flow context. BlockBox establishes a new block formatting context.
		// AnonymousBlockBox and InlineBox handle inline formatting context.

		if b.BoxType == BlockBox {
			// Block Formatting Context
			if child.BoxType == BlockBox || child.BoxType == AnonymousBlockBox {
				childContainingBlock := Dimensions{
					Content: Rect{
						X:      container.Content.X,
						Y:      container.Content.Y + currentYOffset,
						Width:  container.Content.Width,
						Height: 0, // Height is dynamic.
					},
				}
				child.Layout(childContainingBlock)

				// Accumulate height (FUTURE IMPROVEMENT: Margin collapsing).
				currentYOffset += child.Dimensions.Margin.Top + child.Dimensions.Border.Top + child.Dimensions.Padding.Top +
					child.Dimensions.Content.Height +
					child.Dimensions.Padding.Bottom + child.Dimensions.Border.Bottom + child.Dimensions.Margin.Bottom
			}
			// Inline children inside a BlockBox should have been wrapped in AnonymousBlockBox by BuildLayoutTree.

		} else if b.BoxType == AnonymousBlockBox || b.BoxType == InlineBox {
			// Inline Formatting Context (simplified: horizontal flow)
			// (FUTURE IMPROVEMENT: Implement line breaking).
			childContainingBlock := Dimensions{
				Content: Rect{
					X:      container.Content.X + currentXOffset,
					Y:      container.Content.Y + currentYOffset, // Assumes single line for now.
					Width:  container.Content.Width - currentXOffset, // Remaining width
					Height: 0,
				},
			}
			child.Layout(childContainingBlock)

			// Accumulate width for the next sibling.
			currentXOffset += child.Dimensions.Margin.Left + child.Dimensions.Border.Left + child.Dimensions.Padding.Left +
				child.Dimensions.Content.Width +
				child.Dimensions.Padding.Right + child.Dimensions.Border.Right + child.Dimensions.Margin.Right
		}
	}
}

// calculateBlockHeight adjusts the height if it was set to 'auto'.
func (b *LayoutBox) calculateBlockHeight() {
	// If StyledNode is nil (e.g., AnonymousBlockBox), height is purely based on children.
	if b.StyledNode != nil {
		// If height is explicitly set, use that value.
		height := lookupStyle(b.StyledNode.ComputedStyles, "height", "auto")
		if height != "auto" {
			// We use 0 as the reference dimension for explicit height if it's not a percentage (complex dependency loop otherwise).
			b.Dimensions.Content.Height = parseLength(height, 0)
			return
		}
	}

	// If height is auto, it's determined by the extent of its children.
	maxYExtent := 0.0
	for _, child := range b.Children {
		// Calculate the bottom edge of the child's margin box.
		childExtent := child.Dimensions.Content.Y + child.Dimensions.Content.Height +
			child.Dimensions.Padding.Bottom + child.Dimensions.Border.Bottom + child.Dimensions.Margin.Bottom

		// We need the extent relative to the parent's content box start.
		relativeExtent := childExtent - b.Dimensions.Content.Y
		if relativeExtent > maxYExtent {
			maxYExtent = relativeExtent
		}
	}

	b.Dimensions.Content.Height = maxYExtent
}

// calculateInlineDimensions adjusts width and height for inline elements (shrink-to-fit).
func (b *LayoutBox) calculateInlineDimensions(containingBlock Dimensions) {

	isInlineBlock := false
	if b.StyledNode != nil {
		if display, ok := b.StyledNode.Value("display"); ok && display == "inline-block" {
			isInlineBlock = true
		}

		// Handle explicit width/height for inline-block.
		if isInlineBlock {
			width := lookupStyle(b.StyledNode.ComputedStyles, "width", "auto")
			height := lookupStyle(b.StyledNode.ComputedStyles, "height", "auto")

			if width != "auto" {
				b.Dimensions.Content.Width = parseLength(width, containingBlock.Content.Width)
			}
			if height != "auto" {
				b.Dimensions.Content.Height = parseLength(height, 0) // Simplified height calculation
			}

			if width != "auto" && height != "auto" {
				return
			}
		}
	}

	// Calculate width and height based on the extent of children (shrink-to-fit).
	maxXExtent := 0.0
	maxYExtent := 0.0

	// If it's a text node, we must estimate its size.
	if b.StyledNode != nil && b.StyledNode.Node.Type == html.TextNode {
		// Text rendering estimation heuristic: assume average character width and line height.
		// Rough estimate: 8px per character, 16px line height.
		text := b.StyledNode.Node.Data
		maxXExtent = float64(len(strings.TrimSpace(text))) * 8.0
		maxYExtent = 16.0
	} else {
		// If it contains other elements.
		for _, child := range b.Children {
			childWidthExtent := child.Dimensions.Content.X + child.Dimensions.Content.Width +
				child.Dimensions.Padding.Right + child.Dimensions.Border.Right + child.Dimensions.Margin.Right
			relativeWidthExtent := childWidthExtent - b.Dimensions.Content.X

			childHeightExtent := child.Dimensions.Content.Y + child.Dimensions.Content.Height +
				child.Dimensions.Padding.Bottom + child.Dimensions.Border.Bottom + child.Dimensions.Margin.Bottom
			relativeHeightExtent := childHeightExtent - b.Dimensions.Content.Y

			if relativeWidthExtent > maxXExtent {
				maxXExtent = relativeWidthExtent
			}
			if relativeHeightExtent > maxYExtent {
				maxYExtent = relativeHeightExtent
			}
		}
	}

	if !isInlineBlock || lookupStyle(b.StyledNode.ComputedStyles, "width", "auto") == "auto" {
		b.Dimensions.Content.Width = maxXExtent
	}
	if !isInlineBlock || lookupStyle(b.StyledNode.ComputedStyles, "height", "auto") == "auto" {
		b.Dimensions.Content.Height = maxYExtent
	}
}

// --- Helpers for Style Lookup and Parsing ---

func lookupStyle(styles map[parser.Property]parser.Value, property, fallback string) string {
	if val, ok := styles[parser.Property(property)]; ok {
		return string(val)
	}
	return fallback
}

// parseLength parses a CSS length value (px, %, em, rem) into a float64 pixel value.
// Requires the relevant dimension of the containing block for percentage calculations.
func parseLength(value string, referenceDimension float64) float64 {
	value = strings.TrimSpace(value)
	if value == "" || value == "auto" || value == "normal" {
		return 0.0
	}

	// Handle percentages.
	if strings.HasSuffix(value, "%") {
		percent, err := parseFloat(strings.TrimSuffix(value, "%"))
		if err == nil {
			return referenceDimension * (percent / 100.0)
		}
	}

	// Handle pixels.
	if strings.HasSuffix(value, "px") {
		px, err := parseFloat(strings.TrimSuffix(value, "px"))
		if err == nil {
			return px
		}
	}

	// Handle em/rem (simplified: assume base font size of 16px).
	if strings.HasSuffix(value, "em") || strings.HasSuffix(value, "rem") {
		valStr := strings.TrimSuffix(strings.TrimSuffix(value, "em"), "rem")
		val, err := parseFloat(valStr)
		if err == nil {
			return val * 16.0
		}
	}

	// Attempt to parse unitless numbers (treat as pixels or specific values).
	if val, err := parseFloat(value); err == nil {
		return val
	}

	return 0.0
}

// Simplified parseFloat implementation robust to CSS syntax quirks.
func parseFloat(s string) (float64, error) {
	var result float64
	var sign float64 = 1
	var decimalPoint bool
	var decimalPlace float64 = 0.1

	if len(s) == 0 {
		return 0, fmt.Errorf("empty string")
	}

	i := 0
	if s[0] == '-' {
		sign = -1
		i++
	} else if s[0] == '+' {
		i++
	}

	for ; i < len(s); i++ {
		ch := s[i]
		if ch >= '0' && ch <= '9' {
			digit := float64(ch - '0')
			if decimalPoint {
				result += digit * decimalPlace
				decimalPlace *= 0.1
			} else {
				result = result*10 + digit
			}
		} else if ch == '.' && !decimalPoint {
			decimalPoint = true
		} else {
			// Stop parsing at the first invalid character.
			break
		}
	}

	if result == 0 && sign == -1 {
		return 0, nil
	}

	return result * sign, nil
}

func max(a, b float64) float64 {
	if a > b {
		return a
	}
	return b
}

// --- Public Interface for Geometry Retrieval ---

// GetElementGeometry finds the LayoutBox corresponding to the XPath selector and returns its geometry.
func (e *Engine) GetElementGeometry(layoutRoot *LayoutBox, selector string) (*schemas.ElementGeometry, error) {
	if layoutRoot == nil {
		return nil, fmt.Errorf("layout tree is nil")
	}

	// 1. Find the target DOM node using XPath.
	domRoot := findDOMRoot(layoutRoot)
	if domRoot == nil {
		return nil, fmt.Errorf("could not find root DOM node from layout tree")
	}

	targetNode, err := htmlquery.Query(domRoot, selector)
	if err != nil {
		return nil, fmt.Errorf("invalid XPath selector '%s': %w", selector, err)
	}
	if targetNode == nil {
		return nil, fmt.Errorf("element not found matching selector '%s'", selector)
	}

	// 2. Traverse the Layout Tree to find the corresponding LayoutBox.
	box := findLayoutBoxForNode(layoutRoot, targetNode)
	if box == nil {
		// Element exists in DOM but not rendered (e.g., display: none).
		return nil, fmt.Errorf("element '%s' found in DOM but not rendered in Layout Tree (e.g., display: none)", selector)
	}

	// 3. Check visibility: hidden.
	if box.StyledNode != nil && !box.StyledNode.IsVisible() {
		return nil, fmt.Errorf("element '%s' is hidden (visibility: hidden/collapse)", selector)
	}

	// 4. Convert LayoutBox Dimensions to humanoid.ElementGeometry.
	return box.ToElementGeometry(), nil
}

// ToElementGeometry converts the LayoutBox dimensions (the padding box) into the standard geometry format.
func (b *LayoutBox) ToElementGeometry() *schemas.ElementGeometry {
	d := b.Dimensions
	// Calculate the padding box coordinates (similar to getBoundingClientRect).
	x := d.Content.X - d.Padding.Left
	y := d.Content.Y - d.Padding.Top
	width := d.Padding.Left + d.Content.Width + d.Padding.Right
	height := d.Padding.Top + d.Content.Height + d.Padding.Bottom

	// Create vertices for the bounding box (clockwise starting top-left).
	vertices := []float64{
		x, y,
		x + width, y,
		x + width, y + height,
		x, y + height,
	}

	return &schemas.ElementGeometry{
		Vertices: vertices,
		Width:    int64(math.Round(width)),
		Height:   int64(math.Round(height)),
	}
}

// Helper to find the root DOM node from the layout tree root.
func findDOMRoot(box *LayoutBox) *html.Node {
	if box == nil {
		return nil
	}

	// Typically the root layout box corresponds to the root element (<html> or <body>).
	if box.StyledNode != nil && box.StyledNode.Node != nil {
		rootNode := box.StyledNode.Node
		// Traverse up to ensure we get the absolute document root.
		for rootNode.Parent != nil {
			rootNode = rootNode.Parent
		}
		return rootNode
	}

	// Fallback for unusual structures.
	queue := []*LayoutBox{box}
	for len(queue) > 0 {
		currentBox := queue[0]
		queue = queue[1:]

		if currentBox.StyledNode != nil && currentBox.StyledNode.Node != nil {
			rootNode := currentBox.StyledNode.Node
			for rootNode.Parent != nil {
				rootNode = rootNode.Parent
			}
			return rootNode
		}
		queue = append(queue, currentBox.Children...)
	}

	return nil
}

// Helper to find the LayoutBox corresponding to a specific DOM node using DFS.
func findLayoutBoxForNode(root *LayoutBox, target *html.Node) *LayoutBox {
	if root == nil {
		return nil
	}

	// Check if the current box corresponds to the target node.
	if root.StyledNode != nil && root.StyledNode.Node == target {
		return root
	}

	// Recursively search children.
	for _, child := range root.Children {
		if found := findLayoutBoxForNode(child, target); found != nil {
			return found
		}
	}

	return nil
}
