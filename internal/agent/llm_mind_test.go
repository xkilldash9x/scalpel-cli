package agent

import (
	"context"
	"encoding/json"
	"errors"
	"testing"
	"time"

	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/mock"
	"github.com/stretchr/testify/require"
	"go.uber.org/zap/zaptest"

	"github.com/xkilldash9x/scalpel-cli/api/schemas"
	"github.com/xkilldash9x/scalpel-cli/internal/config"
)

// -- Test Setup Helper --

// setupLLMMind initializes the LLMMind and its dependencies for testing.
func setupLLMMind(t *testing.T) (*LLMMind, *MockLLMClient, *MockGraphStore, *CognitiveBus) {
	t.Helper()
	logger := zaptest.NewLogger(t)
	mockLLM := new(MockLLMClient)
	mockKG := new(MockGraphStore)
	// Use a real CognitiveBus to properly test the integration of the OODA loop.
	bus := NewCognitiveBus(logger, 50)

	// A default configuration for our tests.
	cfg := config.AgentConfig{
		LLM: config.LLMRouterConfig{
			DefaultPowerfulModel: "test-model",
			Models:               map[string]config.LLMModelConfig{"test-model": {Model: "test-model"}},
		},
	}

	mind := NewLLMMind(logger, mockLLM, cfg, mockKG, bus)

	// Make sure all our resources are cleaned up when the test is done.
	t.Cleanup(func() {
		mind.Stop()
		bus.Shutdown()
	})

	return mind, mockLLM, mockKG, bus
}

// -- Test Cases: Initialization and State Management --

// TestNewLLMMind_Initialization verifies the initial state and configuration.
func TestNewLLMMind_Initialization(t *testing.T) {
	mind, _, _, _ := setupLLMMind(t)

	// Peeking inside to verify the initial state.
	assert.Equal(t, StateInitializing, mind.currentState)
	assert.NotNil(t, mind.stateReadyChan)
}

// TestLLMMind_SetMission verifies the transition when a new mission is assigned.
func TestLLMMind_SetMission(t *testing.T) {
	mind, _, mockKG, _ := setupLLMMind(t)

	mission := Mission{ID: "mission-set-test", Objective: "Test Objective"}

	// When a mission is set, we expect the mind to first check if a node
	// for this mission already exists in the knowledge graph.
	mockKG.On("GetNode", mock.Anything, "mission-set-test").Return(schemas.Node{}, errors.New("not found")).Once()
	// Since it doesn't exist, it should then add a new mission node.
	mockKG.On("AddNode", mock.Anything, mock.MatchedBy(func(node schemas.Node) bool {
		return node.Type == schemas.NodeMission
	})).Return(nil).Once()

	// Let's do it.
	mind.SetMission(mission)

	// Now verify the state changed as expected.
	mind.mu.RLock()
	assert.Equal(t, StateObserving, mind.currentState)
	assert.Equal(t, "mission-set-test", mind.currentMission.ID)
	mind.mu.RUnlock()

	// A signal should have been sent to kick off the decision loop.
	select {
	case <-mind.stateReadyChan:
	// This is what we wanted.
	default:
		t.Fatal("SetMission did not signal the stateReadyChan as expected")
	}
}

// -- Test Cases: Prompt Generation and Parsing --

// TestParseActionResponse verifies the robust parsing of LLM responses, including markdown formatting.
func TestParseActionResponse(t *testing.T) {
	mind, _, _, _ := setupLLMMind(t)

	// The action we expect to get back from a valid response.
	expectedAction := Action{
		Type:      ActionNavigate,
		Value:     "http://example.com/login",
		Rationale: "Start at login page.",
	}
	validJSON, _ := json.Marshal(expectedAction)

	tests := []struct {
		name        string
		response    string
		expectError bool
		expectType  ActionType
	}{
		{"Valid Plain JSON", string(validJSON), false, ActionNavigate},
		{"Valid Markdown JSON Block", "```json\n" + string(validJSON) + "\n```", false, ActionNavigate},
		{"Valid Markdown Block (no lang)", "```\n" + string(validJSON) + "\n```", false, ActionNavigate},
		{"Extra text and Markdown", "Here is the plan:\n```json\n" + string(validJSON) + "\n```\nProceed.", false, ActionNavigate},
		{"Invalid JSON", `{"type": "NAVIGATE", "value": "http://missing_quote.com}`, true, ""},
		{"Missing Type Field", `{"value": "http://example.com"}`, true, ""},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			// Testing the unexported method directly.
			action, err := mind.parseActionResponse(tt.response)

			if tt.expectError {
				assert.Error(t, err)
			} else {
				require.NoError(t, err)
				assert.Equal(t, tt.expectType, action.Type)
			}
		})
	}
}

// -- Test Cases: OODA Loop Integration --

// TestOODALoop_HappyPath verifies the full cycle: SetMission -> Orient -> Decide -> Act -> Observe -> Orient...
func TestOODALoop_HappyPath(t *testing.T) {
	mind, mockLLM, mockKG, bus := setupLLMMind(t)
	// Use a context with timeout to prevent the test from hanging.
	ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
	defer cancel()

	missionID := "mission-ooda-happy"
	var action1ID string // Will capture the ID generated by the Mind

	missionNode := schemas.Node{ID: missionID, Type: schemas.NodeMission}

	// -- Setup: Mission Initialization (in SetMission) --
	mockKG.On("GetNode", mock.Anything, missionID).Return(schemas.Node{}, errors.New("not found")).Once()
	mockKG.On("AddNode", mock.Anything, mock.MatchedBy(func(node schemas.Node) bool {
		return node.Type == schemas.NodeMission
	})).Return(nil).Once()

	// -- Expectations for Cycle 1 (Mission Start -> Act) --

	// 1. Orient: Gathers context via BFS.
	mockKG.On("GetNode", mock.Anything, missionID).Return(missionNode, nil).Once()
	mockKG.On("GetNeighbors", mock.Anything, missionID).Return([]schemas.Node{}, nil).Once()
	mockKG.On("GetEdges", mock.Anything, missionID).Return([]schemas.Edge{}, nil).Once()

	// 2. Decide: The LLM should be called to generate the next action.
	llmAction1 := Action{Type: ActionNavigate, Value: "http://start.com"}
	llmResponse1, _ := json.Marshal(llmAction1)
	mockLLM.On("Generate", mock.Anything, mock.Anything).Return(string(llmResponse1), nil).Once()

	// 3. Act: The decided action is recorded in the knowledge graph.
	// We use MatchedBy to capture the dynamically generated Action ID.
	mockKG.On("AddNode", mock.Anything, mock.MatchedBy(func(node schemas.Node) bool {
		// Check that we're adding an Action node with the right status.
		props := make(map[string]interface{})
		json.Unmarshal(node.Properties, &props)
		if node.Type == schemas.NodeAction && props["status"] == string(schemas.StatusNew) {
			action1ID = node.ID // This is our chance to grab the ID.
			return true
		}
		return false
	})).Return(nil).Once()
	mockKG.On("AddEdge", mock.Anything, mock.MatchedBy(func(edge schemas.Edge) bool {
		return edge.Type == schemas.RelationshipExecuted
	})).Return(nil).Once()

	// Let's get the mind's processing loops running in the background.
	go func() {
		// Start should run until the context is cancelled.
		if err := mind.Start(ctx); err != nil && !errors.Is(err, context.Canceled) && !errors.Is(err, context.DeadlineExceeded) {
			t.Logf("LLMMind Start returned unexpected error: %v", err)
		}
	}()

	// Subscribe to the bus so we can catch Actions posted by the Mind.
	actionChan, unsubscribeActions := bus.Subscribe(MessageTypeAction)
	defer unsubscribeActions()

	// Trigger the OODA loop by setting the mission.
	mind.SetMission(Mission{ID: missionID, Objective: "Test OODA Happy Path"})

	// Wait for the first action to be posted on the bus.
	var postedAction1 Action
	select {
	case msg := <-actionChan:
		bus.Acknowledge(msg)
		postedAction1 = msg.Payload.(Action)
	case <-ctx.Done():
		t.Fatal("Timeout waiting for Cycle 1 Action on the bus")
	}

	// Make sure we got what we expected from the first cycle.
	require.NotEmpty(t, action1ID, "Action ID should have been captured during KG mock")
	assert.Equal(t, action1ID, postedAction1.ID)

	// -- Expectations for Cycle 2 (Observe -> Act/Conclude) --

	// 4. Observe: The mind processes an observation from the executor.
	// 4a. A new observation node is added.
	mockKG.On("AddNode", mock.Anything, mock.MatchedBy(func(n schemas.Node) bool { return n.Type == schemas.NodeObservation })).Return(nil).Once()
	// 4b. An edge is created from the source action to the new observation.
	mockKG.On("AddEdge", mock.Anything, mock.Anything).Return(nil).Once()
	// 4c. The original action node is retrieved...
	action1Node := schemas.Node{ID: action1ID, Type: schemas.NodeAction, Properties: json.RawMessage(`{}`)}
	mockKG.On("GetNode", mock.Anything, action1ID).Return(action1Node, nil).Once()
	// 4d. ...and then updated with the result.
	mockKG.On("AddNode", mock.Anything, mock.MatchedBy(func(node schemas.Node) bool {
		props := make(map[string]interface{})
		json.Unmarshal(node.Properties, &props)
		return node.ID == action1ID && props["status"] == string(schemas.StatusAnalyzed)
	})).Return(nil).Once()

	// 5. Orient: The context gathering happens again with the updated graph.
	mockKG.On("GetNode", mock.Anything, missionID).Return(missionNode, nil).Once()
	mockKG.On("GetNeighbors", mock.Anything, missionID).Return([]schemas.Node{action1Node}, nil).Once()
	mockKG.On("GetEdges", mock.Anything, missionID).Return([]schemas.Edge{}, nil).Once()
	mockKG.On("GetNeighbors", mock.Anything, action1ID).Return([]schemas.Node{}, nil).Once()
	mockKG.On("GetEdges", mock.Anything, action1ID).Return([]schemas.Edge{}, nil).Once()

	// 6. Decide: The LLM sees the successful result and decides to conclude the mission.
	llmAction2 := Action{Type: ActionConclude}
	llmResponse2, _ := json.Marshal(llmAction2)
	mockLLM.On("Generate", mock.Anything, mock.Anything).Return(string(llmResponse2), nil).Once()

	// 7. Act: The 'Conclude' action is recorded.
	mockKG.On("AddNode", mock.Anything, mock.MatchedBy(func(n schemas.Node) bool { return n.Type == schemas.NodeAction })).Return(nil).Once()
	mockKG.On("AddEdge", mock.Anything, mock.Anything).Return(nil).Once()

	// Trigger the second cycle by posting an observation, just like an executor tool would.
	observation := Observation{
		SourceActionID: action1ID,
		Data:           "success data",
		Result:         ExecutionResult{Status: "success"},
	}
	err := bus.Post(ctx, CognitiveMessage{Type: MessageTypeObservation, Payload: observation})
	require.NoError(t, err)

	// Wait for the second, concluding action.
	select {
	case msg := <-actionChan:
		bus.Acknowledge(msg)
		postedAction2 := msg.Payload.(Action)
		assert.Equal(t, ActionConclude, postedAction2.Type)
	case <-ctx.Done():
		t.Fatal("Timeout waiting for Cycle 2 Action (Conclude) on the bus")
	}

	// Finally, verify that the mind has transitioned to the completed state.
	assert.Eventually(t, func() bool {
		mind.mu.RLock()
		defer mind.mu.RUnlock()
		return mind.currentState == StateCompleted
	}, 2*time.Second, 50*time.Millisecond)

	// Make sure all our mocks were called as we expected.
	mockKG.AssertExpectations(t)
	mockLLM.AssertExpectations(t)
}

// -- Test Cases: Robustness and Error Handling --

// Verifies the Mind transitions to StateFailed if observation processing fails.
func TestOODALoop_ObservationKGFailure(t *testing.T) {
	mind, mockLLM, mockKG, bus := setupLLMMind(t)
	ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
	defer cancel()

	missionID := "mission-fail-obs"

	// -- Mocks for the initial, unrelated decision cycle triggered by SetMission --
	// 1. SetMission is called.
	mockKG.On("GetNode", mock.Anything, missionID).Return(schemas.Node{}, errors.New("not found")).Once()
	mockKG.On("AddNode", mock.Anything, mock.MatchedBy(func(n schemas.Node) bool { return n.Type == schemas.NodeMission })).Return(nil).Once()

	// 2. The first OODA cycle runs. We mock its full flow to succeed gracefully.
	// O(rient)
	mockKG.On("GetNode", mock.Anything, missionID).Return(schemas.Node{ID: missionID}, nil).Maybe()
	mockKG.On("GetNeighbors", mock.Anything, missionID).Return([]schemas.Node{}, nil).Maybe()
	mockKG.On("GetEdges", mock.Anything, missionID).Return([]schemas.Edge{}, nil).Maybe()
	// D(ecide)
	mockLLM.On("Generate", mock.Anything, mock.Anything).Return(`{"type": "NAVIGATE", "value": "http://init.com", "rationale": "initial action"}`, nil).Maybe()
	// A(ct)
	mockKG.On("AddNode", mock.Anything, mock.MatchedBy(func(n schemas.Node) bool { return n.Type == schemas.NodeAction })).Return(nil).Maybe()
	mockKG.On("AddEdge", mock.Anything, mock.Anything).Return(nil).Maybe()

	// -- Mocks for the actual test scenario --
	// This is the critical failure we want to test.
	expectedError := errors.New("KG critical failure")
	mockKG.On("AddNode", mock.Anything, mock.MatchedBy(func(n schemas.Node) bool { return n.Type == schemas.NodeObservation })).Return(expectedError).Once()

	// Start the mind and give it a mission.
	go mind.Start(ctx)
	mind.SetMission(Mission{ID: missionID})

	// Post an observation to trigger the failure.
	// We need to give the initial cycle a moment to run before we post.
	time.Sleep(50 * time.Millisecond)
	observation := Observation{ID: "obs-fail", Data: "some data"}
	err := bus.Post(ctx, CognitiveMessage{Type: MessageTypeObservation, Payload: observation})
	require.NoError(t, err)

	// Verify the mind gives up and enters a failed state.
	assert.Eventually(t, func() bool {
		mind.mu.RLock()
		defer mind.mu.RUnlock()
		return mind.currentState == StateFailed
	}, 2*time.Second, 50*time.Millisecond)
}

// Verifies the Mind handles LLM API failures gracefully.
func TestOODALoop_DecisionLLMFailure(t *testing.T) {
	mind, mockLLM, mockKG, _ := setupLLMMind(t)
	ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
	defer cancel()

	missionID := "mission-llm-fail"
	missionNode := schemas.Node{ID: missionID, Type: schemas.NodeMission}

	// -- Mock Setup in strict execution order --
	// 1. Mock the SetMission calls.
	mockKG.On("GetNode", mock.Anything, missionID).Return(schemas.Node{}, errors.New("not found")).Once()
	mockKG.On("AddNode", mock.Anything, mock.MatchedBy(func(n schemas.Node) bool { return n.Type == schemas.NodeMission })).Return(nil).Once()

	// 2. Mock the decision cycle that the test is targeting.
	// O(rient) must succeed.
	mockKG.On("GetNode", mock.Anything, missionID).Return(missionNode, nil).Once()
	mockKG.On("GetNeighbors", mock.Anything, missionID).Return([]schemas.Node{}, nil).Once()
	mockKG.On("GetEdges", mock.Anything, missionID).Return([]schemas.Edge{}, nil).Once()

	// D(ecide) is the failure point we are testing.
	expectedError := errors.New("LLM API timeout")
	mockLLM.On("Generate", mock.Anything, mock.Anything).Return("", expectedError).Once()

	// Start the mind and trigger the cycle.
	go mind.Start(ctx)
	mind.SetMission(Mission{ID: missionID})

	// -- Corrected Assertion --
	// 1. First, wait for the mind to reach the expected state. This confirms
	// the async operation has finished processing the error.
	assert.Eventually(t, func() bool {
		mind.mu.RLock()
		currentState := mind.currentState
		mind.mu.RUnlock()
		return currentState == StateObserving
	}, 2*time.Second, 50*time.Millisecond, "Mind did not return to OBSERVING state after LLM failure.")

	// 2. NOW that we know the operation is complete, we can safely assert
	// that all our mock expectations were met.
	mockLLM.AssertExpectations(t)
	mockKG.AssertExpectations(t)
}

// Verifies the Mind fails if it cannot record its decided action.
func TestOODALoop_ActionKGFailure(t *testing.T) {
	mind, mockLLM, mockKG, _ := setupLLMMind(t)
	ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
	defer cancel()

	missionID := "mission-action-kg-fail"
	missionNode := schemas.Node{ID: missionID, Type: schemas.NodeMission}

	// -- Mock Setup in strict execution order --
	// 1. Mock the SetMission calls.
	mockKG.On("GetNode", mock.Anything, missionID).Return(schemas.Node{}, errors.New("not found")).Once()
	mockKG.On("AddNode", mock.Anything, mock.MatchedBy(func(n schemas.Node) bool { return n.Type == schemas.NodeMission })).Return(nil).Once()

	// 2. Mock O(rient) and D(ecide) to succeed.
	mockKG.On("GetNode", mock.Anything, missionID).Return(missionNode, nil).Once()
	mockKG.On("GetNeighbors", mock.Anything, missionID).Return([]schemas.Node{}, nil).Once()
	mockKG.On("GetEdges", mock.Anything, missionID).Return([]schemas.Edge{}, nil).Once()
	llmResponse, _ := json.Marshal(Action{Type: ActionClick})
	mockLLM.On("Generate", mock.Anything, mock.Anything).Return(string(llmResponse), nil).Once()

	// 3. A(ct) is the failure point we are testing.
	expectedError := errors.New("KG write failure")
	mockKG.On("AddNode", mock.Anything, mock.MatchedBy(func(n schemas.Node) bool { return n.Type == schemas.NodeAction })).Return(expectedError).Once()

	// Start the mind and trigger the cycle.
	go mind.Start(ctx)
	mind.SetMission(Mission{ID: missionID})

	// If the mind can't record what it decided to do, that's a critical failure.
	assert.Eventually(t, func() bool {
		mind.mu.RLock()
		defer mind.mu.RUnlock()
		return mind.currentState == StateFailed
	}, 2*time.Second, 50*time.Millisecond)
}