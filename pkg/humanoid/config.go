// pkg/humanoid/config.go
package humanoid

import (
	"math"
	"math/rand"
)

// Config holds the parameters that define the behavior and characteristics
// of the humanoid simulation. It includes both distribution parameters for
// defining archetypes and instance parameters used during a session.
type Config struct {
	Rng *rand.Rand

	// -- Distribution Parameters (Define the Persona archetype) --

	// Fitts's Law Parameters (Movement Time = A + B * ID)
	FittsAMean, FittsAStdDev float64
	FittsBMean, FittsBStdDev float64

	// Motor Control Dynamics (Damped Harmonic Oscillator Model)
	OmegaMean, OmegaStdDev float64 // Responsiveness/speed
	ZetaMean, ZetaStdDev   float64 // Damping ratio

	// Noise and Tremor
	GaussianStrengthMean, GaussianStrengthStdDev float64
	PerlinAmplitudeMean, PerlinAmplitudeStdDev   float64

	// Typing Behavior
	TypoRateMean, TypoRateStdDev       float64
	KeyHoldMeanMs, KeyHoldStdDevMs     float64 // Key hold duration (Dwell time)

	// -- Instance Parameters (Fixed for the session, generated by FinalizeSessionPersona) --
	// These provide temporal consistency for the session.

	FittsA, FittsB       float64
	Omega, Zeta          float64
	GaussianStrength     float64
	PerlinAmplitude      float64
	TypoRate             float64
	KeyHoldMean, KeyHoldStdDev float64 // Session-specific key hold timing

	// -- Shared Parameters (Apply to both distribution and instance) --

	// Conditional Typo Probabilities (Proportions)
	TypoNeighborRate  float64
	TypoTransposeRate float64
	TypoOmissionRate  float64
	TypoInsertionRate float64

	// Scrolling Behavior
	ScrollReadDensityFactor     float64
	ScrollMouseWheelProbability float64 // Probability of using mouse wheel vs JS smooth scroll
	ScrollRegressionProbability float64 // Probability of scrolling backward slightly (re-reading)
	ScrollOvershootProbability  float64

	// Fatigue Modeling
	FatigueIncreaseRate float64 // Rate fatigue accumulates per action intensity unit
	FatigueRecoveryRate float64 // Rate fatigue recovers per second of inactivity

	// Movement Refinement
	MicroCorrectionThreshold float64 // Distance from target (pixels) where terminal phase dynamics begin
}

// Persona represents a predefined set of configurations.
type Persona string

const (
	PersonaDefault      Persona = "Default"
	PersonaFastSkilled  Persona = "FastSkilled"
	PersonaSlowCautious Persona = "SlowCautious"
)

// GetConfigForPersona returns the configuration archetype for a specific persona.
func GetConfigForPersona(persona Persona) Config {
	var c Config
	switch persona {
	case PersonaFastSkilled:
		c = DefaultConfig()
		c.FittsAMean = 70.0
		c.FittsBMean = 100.0
		c.OmegaMean = 35.0
		c.ZetaMean = 0.75 // Underdamped (faster, less accurate)
		c.TypoRateMean = 0.02
		c.KeyHoldMeanMs = 40.0
		c.GaussianStrengthMean = 0.4
		c.FatigueIncreaseRate = 0.003 // More stamina
		c.ScrollMouseWheelProbability = 0.85
		c.MicroCorrectionThreshold = 30.0

	case PersonaSlowCautious:
		c = DefaultConfig()
		c.FittsAMean = 200.0
		c.FittsBMean = 180.0
		c.OmegaMean = 18.0
		c.ZetaMean = 1.2 // Overdamped (slower, more deliberate)
		c.TypoRateMean = 0.06
		c.KeyHoldMeanMs = 75.0
		c.GaussianStrengthMean = 0.8
		c.FatigueIncreaseRate = 0.008 // Less stamina
		c.ScrollRegressionProbability = 0.15
		c.MicroCorrectionThreshold = 60.0

	case PersonaDefault:
		fallthrough
	default:
		c = DefaultConfig()
	}
	c.NormalizeTypoRates()
	return c
}

// DefaultConfig returns a configuration representing an average, skilled adult user archetype.
func DefaultConfig() Config {
	c := Config{
		Rng: nil,

		// Fitts's Law
		FittsAMean: 100.0, FittsAStdDev: 15.0,
		FittsBMean: 120.0, FittsBStdDev: 20.0,

		// Dynamics: Responsive and slightly underdamped.
		OmegaMean: 28.0, OmegaStdDev: 4.0,
		ZetaMean:  0.90, ZetaStdDev: 0.1,

		// Noise
		GaussianStrengthMean: 0.5, GaussianStrengthStdDev: 0.1,
		PerlinAmplitudeMean:  2.5, PerlinAmplitudeStdDev: 0.5,

		// Typing
		TypoRateMean:    0.04, TypoRateStdDev: 0.01,
		KeyHoldMeanMs: 55.0, KeyHoldStdDevMs: 15.0,

		// Typo distributions
		TypoNeighborRate:  0.40,
		TypoTransposeRate: 0.25,
		TypoOmissionRate:  0.20,
		TypoInsertionRate: 0.15,

		// Scrolling
		ScrollReadDensityFactor:     0.5,
		ScrollMouseWheelProbability: 0.70,
		ScrollRegressionProbability: 0.10,
		ScrollOvershootProbability:  0.25,

		// Fatigue
		FatigueIncreaseRate: 0.005,
		FatigueRecoveryRate: 0.01, // Recovers during pauses (1% per second)

		// Movement Refinement
		MicroCorrectionThreshold: 50.0,
	}
	c.NormalizeTypoRates()
	return c
}

// Helper for Gaussian sampling
func sampleGaussian(rng *rand.Rand, mean, stdDev float64) float64 {
	if rng == nil {
		return mean
	}
	return mean + rng.NormFloat64()*stdDev
}

// FinalizeSessionPersona generates the fixed instance parameters for a session
// based on the distribution parameters. This ensures temporal consistency.
func (c *Config) FinalizeSessionPersona(rng *rand.Rand) {
	c.Rng = rng

	c.FittsA = sampleGaussian(rng, c.FittsAMean, c.FittsAStdDev)
	c.FittsB = sampleGaussian(rng, c.FittsBMean, c.FittsBStdDev)

	c.Omega = sampleGaussian(rng, c.OmegaMean, c.OmegaStdDev)
	c.Zeta = sampleGaussian(rng, c.ZetaMean, c.ZetaStdDev)

	c.GaussianStrength = sampleGaussian(rng, c.GaussianStrengthMean, c.GaussianStrengthStdDev)
	c.PerlinAmplitude = sampleGaussian(rng, c.PerlinAmplitudeMean, c.PerlinAmplitudeStdDev)

	c.TypoRate = sampleGaussian(rng, c.TypoRateMean, c.TypoRateStdDev)
	c.KeyHoldMean = sampleGaussian(rng, c.KeyHoldMeanMs, c.KeyHoldStdDevMs)
	c.KeyHoldStdDev = c.KeyHoldStdDevMs // Use the distribution StdDev for runtime variation around the session mean

	// Ensure parameters are within reasonable bounds
	c.Omega = math.Max(5.0, c.Omega)
	c.Zeta = math.Max(0.1, c.Zeta)
	c.TypoRate = math.Max(0.0, math.Min(0.2, c.TypoRate)) // Cap typo rate at 20%
	c.KeyHoldMean = math.Max(20.0, c.KeyHoldMean)
}

// NormalizeTypoRates ensures the conditional typo probabilities sum up to 1.
func (c *Config) NormalizeTypoRates() {
	total := c.TypoNeighborRate + c.TypoTransposeRate + c.TypoOmissionRate + c.TypoInsertionRate
	if total <= 1e-9 {
		// If total is near zero, assign a default uniform distribution if typos are expected, otherwise keep them zero.
		if c.TypoRateMean > 0 || c.TypoRate > 0 {
			c.TypoNeighborRate = 0.25
			c.TypoTransposeRate = 0.25
			c.TypoOmissionRate = 0.25
			c.TypoInsertionRate = 0.25
		}
		return
	}
	c.TypoNeighborRate /= total
	c.TypoTransposeRate /= total
	c.TypoOmissionRate /= total
	c.TypoInsertionRate /= total
}
